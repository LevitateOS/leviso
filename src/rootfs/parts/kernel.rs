//! Kernel building and installation.
//!
//! # CRITICAL FOR BARE METAL BOOT
//!
//! Without a kernel and modules, the system will NOT boot on real hardware.
//! The boot entry expects:
//! - /boot/vmlinuz - The kernel image
//! - /boot/initramfs.img - Generated by dracut post-install
//!
//! Dracut needs:
//! - /usr/lib/modules/<version>/ - Kernel modules for hardware support
//! - /usr/lib/firmware/ - Linux firmware for drivers
//!
//! This module builds the kernel from source and installs it to the tarball.
//! Initramfs generation happens during installation via `dracut --force`.

use anyhow::{bail, Context, Result};
use std::fs;
use std::path::Path;
use std::process::Command;

use super::super::context::BuildContext;

/// Kernel configuration options for a desktop/workstation system.
///
/// Based on x86_64_defconfig with additions for:
/// - Systemd requirements (cgroups v2, autofs4, etc.)
/// - Virtualization (KVM, virtio)
/// - Common hardware (NVME, SATA, USB, network cards)
/// - Filesystem support (ext4, btrfs, xfs, fat)
const KERNEL_CONFIG: &str = r#"
# LevitateOS Kernel Configuration
# Based on x86_64_defconfig with desktop/workstation additions

# Basic identity
CONFIG_LOCALVERSION="-levitate"

# Processor type
CONFIG_X86_64=y
CONFIG_SMP=y
CONFIG_PREEMPT_VOLUNTARY=y

# Systemd requirements
CONFIG_DEVTMPFS=y
CONFIG_DEVTMPFS_MOUNT=y
CONFIG_TMPFS=y
CONFIG_TMPFS_POSIX_ACL=y
CONFIG_TMPFS_XATTR=y
CONFIG_CGROUPS=y
CONFIG_CGROUP_FREEZER=y
CONFIG_CGROUP_PIDS=y
CONFIG_CGROUP_DEVICE=y
CONFIG_CPUSETS=y
CONFIG_CGROUP_CPUACCT=y
CONFIG_MEMCG=y
CONFIG_BLK_CGROUP=y
CONFIG_CGROUP_SCHED=y
CONFIG_FAIR_GROUP_SCHED=y
CONFIG_NET_CLS_CGROUP=y
CONFIG_CGROUP_NET_PRIO=y
CONFIG_CGROUP_BPF=y
CONFIG_NAMESPACES=y
CONFIG_USER_NS=y
CONFIG_PID_NS=y
CONFIG_NET_NS=y
CONFIG_INOTIFY_USER=y
CONFIG_SIGNALFD=y
CONFIG_TIMERFD=y
CONFIG_EPOLL=y
CONFIG_FHANDLE=y
CONFIG_AUTOFS_FS=y
CONFIG_DMIID=y
CONFIG_SECCOMP=y
CONFIG_SECCOMP_FILTER=y

# Module support
CONFIG_MODULES=y
CONFIG_MODULE_UNLOAD=y
CONFIG_MODULE_FORCE_UNLOAD=y
CONFIG_MODVERSIONS=y

# Block devices
CONFIG_BLOCK=y
CONFIG_BLK_DEV=y
CONFIG_BLK_DEV_SD=y
CONFIG_BLK_DEV_NVME=y
CONFIG_SATA_AHCI=y
CONFIG_ATA=y
CONFIG_ATA_SFF=y
CONFIG_ATA_BMDMA=y
CONFIG_ATA_PIIX=y
CONFIG_SCSI=y
CONFIG_BLK_DEV_SR=y

# Partitions
CONFIG_PARTITION_ADVANCED=y
CONFIG_MSDOS_PARTITION=y
CONFIG_EFI_PARTITION=y

# Filesystems
CONFIG_EXT4_FS=y
CONFIG_EXT4_FS_POSIX_ACL=y
CONFIG_XFS_FS=y
CONFIG_BTRFS_FS=y
CONFIG_VFAT_FS=y
CONFIG_FAT_DEFAULT_UTF8=y
CONFIG_TMPFS=y
CONFIG_PROC_FS=y
CONFIG_SYSFS=y
CONFIG_DEVPTS_FS=y
CONFIG_ISO9660_FS=y
CONFIG_UDF_FS=y
CONFIG_SQUASHFS=y
CONFIG_SQUASHFS_XZ=y
CONFIG_OVERLAY_FS=y

# Network
CONFIG_NET=y
CONFIG_PACKET=y
CONFIG_UNIX=y
CONFIG_INET=y
CONFIG_IP_MULTICAST=y
CONFIG_IPV6=y
CONFIG_NETDEVICES=y
CONFIG_ETHERNET=y
CONFIG_NET_VENDOR_INTEL=y
CONFIG_E1000E=y
CONFIG_IGB=y
CONFIG_IGBVF=y
CONFIG_IXGBE=y
CONFIG_I40E=y
CONFIG_ICE=y
CONFIG_NET_VENDOR_REALTEK=y
CONFIG_R8169=y

# USB
CONFIG_USB_SUPPORT=y
CONFIG_USB=y
CONFIG_USB_PCI=y
CONFIG_USB_XHCI_HCD=y
CONFIG_USB_EHCI_HCD=y
CONFIG_USB_OHCI_HCD=y
CONFIG_USB_STORAGE=y
CONFIG_USB_UAS=y
CONFIG_USB_HID=y

# Input
CONFIG_INPUT=y
CONFIG_INPUT_KEYBOARD=y
CONFIG_KEYBOARD_ATKBD=y
CONFIG_INPUT_MOUSE=y
CONFIG_MOUSE_PS2=y
CONFIG_SERIO=y
CONFIG_SERIO_I8042=y

# Graphics (basic for initramfs console)
CONFIG_VGA_CONSOLE=y
CONFIG_FRAMEBUFFER_CONSOLE=y
CONFIG_DRM=y
CONFIG_DRM_FBDEV_EMULATION=y

# Virtio (for VM testing)
CONFIG_VIRTIO_PCI=y
CONFIG_VIRTIO_BLK=y
CONFIG_VIRTIO_NET=y
CONFIG_VIRTIO_CONSOLE=y
CONFIG_VIRTIO_INPUT=y
CONFIG_VIRTIO_SCSI=y
CONFIG_HW_RANDOM_VIRTIO=y
CONFIG_DRM_VIRTIO_GPU=y

# EFI
CONFIG_EFI=y
CONFIG_EFI_STUB=y
CONFIG_EFI_MIXED=y
CONFIG_EFIVAR_FS=y

# Serial console (for debugging)
CONFIG_SERIAL_8250=y
CONFIG_SERIAL_8250_CONSOLE=y

# Compression (initramfs)
CONFIG_RD_GZIP=y
CONFIG_RD_XZ=y
CONFIG_RD_ZSTD=y

# Crypto
CONFIG_CRYPTO=y
CONFIG_CRYPTO_AES=y
CONFIG_CRYPTO_SHA256=y
CONFIG_CRYPTO_SHA512=y

# Performance
CONFIG_HIGH_RES_TIMERS=y
CONFIG_NO_HZ_COMMON=y
CONFIG_NO_HZ_IDLE=y
"#;

/// Build the kernel from source.
///
/// Returns the kernel version string (e.g., "6.18.0-levitate").
pub fn build_kernel(kernel_source: &Path, output_dir: &Path) -> Result<String> {
    println!("Building kernel from {}...", kernel_source.display());

    if !kernel_source.exists() {
        bail!(
            "Kernel source not found at {}\n\
             Run: git submodule update --init linux",
            kernel_source.display()
        );
    }

    // Check for Makefile
    if !kernel_source.join("Makefile").exists() {
        bail!("Invalid kernel source - no Makefile found");
    }

    // Create output directory
    fs::create_dir_all(output_dir)?;
    let build_dir = output_dir.join("kernel-build");
    fs::create_dir_all(&build_dir)?;

    // Write our config
    let config_path = build_dir.join(".config");

    // Start with x86_64 defconfig
    println!("  Generating base config from defconfig...");
    let defconfig = Command::new("make")
        .args(["-C", kernel_source.to_str().unwrap()])
        .arg(format!("O={}", build_dir.display()))
        .arg("x86_64_defconfig")
        .output()
        .context("Failed to run make defconfig")?;

    if !defconfig.status.success() {
        bail!(
            "make defconfig failed:\n{}",
            String::from_utf8_lossy(&defconfig.stderr)
        );
    }

    // Apply our custom options using scripts/config
    println!("  Applying LevitateOS kernel config...");
    apply_kernel_config(&config_path, kernel_source)?;

    // Run olddefconfig to resolve dependencies
    println!("  Resolving config dependencies...");
    let olddefconfig = Command::new("make")
        .args(["-C", kernel_source.to_str().unwrap()])
        .arg(format!("O={}", build_dir.display()))
        .arg("olddefconfig")
        .output()
        .context("Failed to run make olddefconfig")?;

    if !olddefconfig.status.success() {
        bail!(
            "make olddefconfig failed:\n{}",
            String::from_utf8_lossy(&olddefconfig.stderr)
        );
    }

    // Get the number of CPUs for parallel build
    let cpus = std::thread::available_parallelism()
        .map(|n| n.get())
        .unwrap_or(4);

    // Build kernel
    println!("  Building kernel (this will take a while)...");
    let build = Command::new("make")
        .args(["-C", kernel_source.to_str().unwrap()])
        .arg(format!("O={}", build_dir.display()))
        .arg(format!("-j{}", cpus))
        .output()
        .context("Failed to run make")?;

    if !build.status.success() {
        bail!(
            "Kernel build failed:\n{}",
            String::from_utf8_lossy(&build.stderr)
        );
    }

    // Build modules
    println!("  Building modules...");
    let modules = Command::new("make")
        .args(["-C", kernel_source.to_str().unwrap()])
        .arg(format!("O={}", build_dir.display()))
        .arg(format!("-j{}", cpus))
        .arg("modules")
        .output()
        .context("Failed to build modules")?;

    if !modules.status.success() {
        bail!(
            "Module build failed:\n{}",
            String::from_utf8_lossy(&modules.stderr)
        );
    }

    // Get kernel version
    let version = get_kernel_version(&build_dir)?;
    println!("  Kernel version: {}", version);

    Ok(version)
}

/// Apply our kernel configuration options.
fn apply_kernel_config(config_path: &Path, _kernel_source: &Path) -> Result<()> {
    // Read current config
    let mut config = fs::read_to_string(config_path).unwrap_or_default();

    // Parse and apply our options
    for line in KERNEL_CONFIG.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        if let Some((key, _value)) = line.split_once('=') {
            // Remove any existing setting for this key
            let pattern = format!("{}=", key);
            let pattern_not = format!("# {} is not set", key);
            config = config
                .lines()
                .filter(|l| !l.starts_with(&pattern) && !l.starts_with(&pattern_not))
                .collect::<Vec<_>>()
                .join("\n");

            // Add our setting
            config.push('\n');
            config.push_str(line);
        }
    }

    fs::write(config_path, config)?;
    Ok(())
}

/// Get the kernel version from the build directory.
fn get_kernel_version(build_dir: &Path) -> Result<String> {
    let release_path = build_dir.join("include/config/kernel.release");
    if release_path.exists() {
        return Ok(fs::read_to_string(&release_path)?.trim().to_string());
    }

    // Fallback: read from Makefile
    let makefile = build_dir.join("Makefile");
    if makefile.exists() {
        let content = fs::read_to_string(&makefile)?;
        let mut version = String::new();
        let mut patchlevel = String::new();
        let mut sublevel = String::new();
        let mut extraversion = String::new();

        for line in content.lines() {
            if let Some(v) = line.strip_prefix("VERSION = ") {
                version = v.trim().to_string();
            } else if let Some(v) = line.strip_prefix("PATCHLEVEL = ") {
                patchlevel = v.trim().to_string();
            } else if let Some(v) = line.strip_prefix("SUBLEVEL = ") {
                sublevel = v.trim().to_string();
            } else if let Some(v) = line.strip_prefix("EXTRAVERSION = ") {
                extraversion = v.trim().to_string();
            }
        }

        if !version.is_empty() && !patchlevel.is_empty() {
            let ver = format!("{}.{}.{}{}", version, patchlevel, sublevel, extraversion);
            return Ok(ver);
        }
    }

    bail!("Could not determine kernel version")
}

/// Install kernel and modules to staging directory.
pub fn install_kernel(
    kernel_source: &Path,
    build_output: &Path,
    staging: &Path,
) -> Result<String> {
    let build_dir = build_output.join("kernel-build");

    // Verify kernel was built
    let vmlinux = build_dir.join("arch/x86/boot/bzImage");
    if !vmlinux.exists() {
        bail!(
            "Kernel not built. Run build_kernel() first.\n\
             Expected: {}",
            vmlinux.display()
        );
    }

    let version = get_kernel_version(&build_dir)?;
    println!("Installing kernel {} to staging...", version);

    // Create directories
    let boot_dir = staging.join("boot");
    let modules_dir = staging.join("usr/lib/modules").join(&version);
    fs::create_dir_all(&boot_dir)?;
    fs::create_dir_all(&modules_dir)?;

    // Copy kernel
    let kernel_dest = boot_dir.join("vmlinuz");
    fs::copy(&vmlinux, &kernel_dest)?;
    println!("  Installed /boot/vmlinuz");

    // Install modules using make modules_install
    println!("  Installing modules to /usr/lib/modules/{}...", version);
    let modules_install = Command::new("make")
        .args(["-C", kernel_source.to_str().unwrap()])
        .arg(format!("O={}", build_dir.display()))
        .arg(format!("INSTALL_MOD_PATH={}", staging.display()))
        .arg("modules_install")
        .output()
        .context("Failed to install modules")?;

    if !modules_install.status.success() {
        bail!(
            "Module install failed:\n{}",
            String::from_utf8_lossy(&modules_install.stderr)
        );
    }

    // Remove source/build symlinks (point to build machine paths)
    let _ = fs::remove_file(modules_dir.join("source"));
    let _ = fs::remove_file(modules_dir.join("build"));

    // Count installed modules
    let module_count = walkdir::WalkDir::new(&modules_dir)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| e.path().extension().map(|ext| ext == "ko" || ext == "xz").unwrap_or(false))
        .count();
    println!("  Installed {} kernel modules", module_count);

    Ok(version)
}

/// Copy kernel and modules to rootfs staging.
///
/// Call this from builder.rs after RPM extraction.
pub fn copy_kernel(ctx: &BuildContext) -> Result<()> {
    // Check if kernel is already built
    let kernel_build = ctx.output.join("kernel-build");
    let vmlinuz = kernel_build.join("arch/x86/boot/bzImage");

    if !vmlinuz.exists() {
        println!("Kernel not built - skipping kernel installation");
        println!("  To build: cd ../linux && make x86_64_defconfig && make -j$(nproc)");
        println!("  Or use 'leviso kernel' command (when implemented)");
        return Ok(());
    }

    // Get version and install
    let version = get_kernel_version(&kernel_build)?;
    println!("Installing kernel {} to rootfs...", version);

    // Copy kernel to /boot
    let boot_dir = ctx.staging.join("boot");
    fs::create_dir_all(&boot_dir)?;
    fs::copy(&vmlinuz, boot_dir.join("vmlinuz"))?;
    println!("  /boot/vmlinuz");

    // Modules should already be in staging from install_kernel()
    // but verify they exist
    let modules_dir = ctx.staging.join("usr/lib/modules").join(&version);
    if modules_dir.exists() {
        println!("  /usr/lib/modules/{}/", version);
    } else {
        println!("  Warning: modules not found at {}", modules_dir.display());
    }

    Ok(())
}
